---
title: 221022 TIL | 이펙티브 타입스크립트_&#35;3 타입 공간과 값
tags: [TypeScrip, TIL]
---

### 타입스크립트의 타입 공간, 값 공간

- 타입스크립트의 심벌은 타입 공간이나 값 공간 중 한 곳에 존재한다.
- 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있다.
- 예제의 interface Cylinder와 const Cylinder는 아무런 관련이 없다. 상황에 따라서 타입으로 쓰일 수도 값으로 쓰일 수도 있다.
    - 하지만 이런 점이 가끔 오류를 발생시킨다.

```tsx
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```

#### 타입 공간, 값 공간이 같아 오류가 발생하는 케이스

```tsx
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
       // ~~~~~~ Property 'radius' does not exist on type '{}'
  }
}
```

- instanceof는 1. 런타임 연산자이고 2. 값에 대해 연산을 한다
- 때문에 instanceof Cylinder는 **타입이 아닌 함수**를 참조한다.
    - 타입 코드명과 값 코드명이 같을 경우 혼란스러워지는 이유이다.

### 타입 공간 값 공간에 대한 개념

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득하는 것이 중요하다.

```tsx
type T1 = 'string literal';
type T2 = 123;
const v1 = 'string literal';
const v2 = 123;
```

- `type, interface` 다음에 나오는 심벌은 `타입`인 반면 `const, let` 선언에 쓰이는 것은 `값`이다.
- 타입스크립트 플레이그라운드에서 타입스크립트로 구문을 작성하면 변환된 자바스크립트 코드를 보여준다.
    
    [JavaScript With Syntax For Types.](https://www.typescriptlang.org/)
    
    - 예제의 자바스크립트 코드
    
    ```tsx
    const v1 = 'string literal';
    const v2 = 123;
    ```
    

> 자바스크립트 코드처럼 **모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.**
type, interface같은 키워드는 타입 공간에만 존재한다는 것을 기억하자.
> 

#### 타입, 값 번갈아서 선언하기

- 타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입이지만, = 다음에 오는 모든 것은 값이다.

```tsx
interface Person {
  first: string;
  last: string;
}
const p: Person = { first: 'Jane', last: 'Jacobs' };
//    -           --------------------------------- Values
//       ------ Type
function email(p: Person, subject: string, body: string): Response {
  //     ----- -          -------          ----  Values
  //              ------           ------        ------   -------- Types
  // COMPRESS
  return new Response();
  // END
}
```

### class와 enum은 타입과 값 두 가지 모두 사용한 예약어

```tsx
class Cylinder {
  radius=1;
  height=1;
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape  // OK, type is Cylinder
    shape.radius  // OK, type is number
  }
}
```

- 클래스가 타입으로 쓰일 때 : 형태(속성, 메서드) 사용
- 클래스가 값으로 쓰일 때 : 생성자 사용
    
    

## 타입스크립트에서 typeof 연산자

- typeof 연산자는 자바스크립트에도 존재하지만, 타입스크립트 타입이나 인터페이스 문법에 확장하여 사용할 수 있다.

```tsx
interface Person {
  first: string;
  last: string;
}
const p: Person = { first: 'Jane', last: 'Jacobs' };
//    -           --------------------------------- Values
//       ------ Type
function email(p: Person, subject: string, body: string): Response {
  //     ----- -          -------          ----  Values
  //              ------           ------        ------   -------- Types
  // COMPRESS
  return new Response();
  // END
}

class Cylinder {
  radius=1;
  height=1;
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape  // OK, type is Cylinder
    shape.radius  // OK, type is number
  }
}
type T1 = typeof p;  // Type is Person
type T2 = typeof email;
    // Type is (p: Person, subject: string, body: string) => Response

const v1 = typeof p;  // Value is "object"
const v2 = typeof email;  // Value is "function"
```

- typeof는 값을 읽어서 타입스크립트 타입을 반환한다.
- **타입 공간**의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있고 type 구문으로 이름을 붙이는 용도로도 사용할 수 있다.
- **값 공간**의 typeof는 자바스크립트 런타임 타입을 가리키는 문자열을 반환한다.
    - string, number, boolean, undefined, object, function

```tsx
const v = typeof Cylinder;  // 타입이 function
type T = typeof Cylinder;  // 타입이 typeof Cylinder
```

- 클래스가 실제 함수로 구현되기 때문에 첫번째 줄의 값은 function이 된다.
- 두번째 줄의 값의 Cylinder는 ****인스턴스의 타입이 아닌 new 키워드를 사용했을 때 볼 수 있는 생성자 함수이다.

```tsx
declare let fn: T;
const c = new fn();  // Type is Cylinder
```

- InstanceType<Type>을 사용해 생성자 타입과 인스턴스 타입을 전환할 수도 있다.
    - InstanceType<Type> : 타입에서 생성자 함수의 인스턴스 타입으로 구성된 타입을 구성합니다.

```tsx
type C = InstanceType<typeof Cylinder>;  // 타입이 Cylinder
```

### 출처
- 이펙티브 타입스크립트